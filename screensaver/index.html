<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Screensaver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
        }

        #pixelCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <canvas id="pixelCanvas"></canvas>

    <script>
        // Canvas setup
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        
        // Pixel grid configuration
        const PIXEL_SIZE = 3; // Size of each "pixel" in actual pixels
        let GRID_WIDTH = 80; // Number of pixels wide
        let GRID_HEIGHT = 60; // Number of pixels tall
        
        // Color palette for variety - wide range of vibrant colors
        const colorPalette = [
            // Reds
            '#FF0000', '#FF1744', '#FF5252', '#FF6B6B', '#F44336', '#E91E63', '#C62828', '#D32F2F',
            '#C94C4C', '#F67280', '#E74C3C', '#FF5733', '#DC143C', '#B22222', '#8B0000',
            // Pinks and Purples
            '#FF69B4', '#FF1493', '#FFB6C1', '#FFC0CB', '#FF80AB', '#F48FB1', '#CE93D8', '#BA68C8',
            '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C', '#BB8FCE', '#C06C84',
            '#6C5B7B', '#9B59B6', '#8E44AD', '#663399', '#DA70D6', '#EE82EE', '#DDA0DD',
            // Blues
            '#0000FF', '#0D47A1', '#1565C0', '#1976D2', '#1E88E5', '#2196F3', '#42A5F5', '#64B5F6',
            '#03A9F4', '#00BCD4', '#00ACC1', '#0097A7', '#00838F', '#006064', '#3F51B5', '#5C6BC0',
            '#7986CB', '#3949AB', '#303F9F', '#283593', '#1A237E', '#45B7D1', '#4ECDC4', '#85C1E2',
            '#87CEEB', '#4682B4', '#5F9EA0', '#1E90FF', '#4169E1', '#6495ED', '#00BFFF', '#ADD8E6',
            // Greens
            '#00FF00', '#00E676', '#00C853', '#00BFA5', '#009688', '#00897B', '#00796B', '#00695C',
            '#004D40', '#1B5E20', '#2E7D32', '#388E3C', '#43A047', '#4CAF50', '#66BB6A', '#81C784',
            '#8BC34A', '#9CCC65', '#AED581', '#C5E1A5', '#CDDC39', '#D4E157', '#DCE775', '#00FF7F',
            '#3CB371', '#2E8B57', '#228B22', '#32CD32', '#7FFF00', '#ADFF2F', '#98D8C8',
            // Yellows and Oranges
            '#FFFF00', '#FFEA00', '#FFD600', '#FFEB3B', '#FFF176', '#FFF59D', '#FFF9C4', '#F9FBE7',
            '#F0F4C3', '#F7DC6F', '#FFC107', '#FFB300', '#FFA000', '#FF8F00', '#FF6F00', '#FF9800',
            '#FB8C00', '#F57C00', '#EF6C00', '#E65100', '#FF5722', '#F4511E', '#E64A19', '#D84315',
            '#BF360C', '#FFA07A', '#FF8C00', '#FF7F50', '#FFA500', '#FFD700', '#F39C12', '#E67E22',
            // Teals and Cyans
            '#00FFFF', '#00E5FF', '#00B8D4', '#0097A7', '#00838F', '#006064', '#26C6DA', '#4DD0E1',
            '#80DEEA', '#B2EBF2', '#E0F7FA', '#18FFFF', '#84FFFF', '#A7FFEB', '#1DE9B6', '#64FFDA',
            // Misc Colors
            '#FFFFFF', '#F5F5F5', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575', '#616161', '#424242',
            '#212121', '#FF4081', '#FF80AB', '#EA80FC', '#B388FF', '#8C9EFF', '#82B1FF', '#80D8FF',
            '#84FFFF', '#A7FFEB', '#B9F6CA', '#CCFF90', '#F4FF81', '#FFFF8D', '#FFE57F', '#FFD180',
            '#FF9E80', '#F8B195', '#A52A2A', '#8B4513', '#D2691E', '#CD853F', '#BC8F8F', '#B8860B',
            '#DAA520', '#808000', '#556B2F', '#6B8E23', '#2F4F4F', '#355C7D', '#607D8B', '#78909C',
            '#90A4AE', '#B0BEC5', '#CFD8DC', '#ECEFF1', '#795548', '#8D6E63', '#A1887F', '#BCAAA4'
        ];
        
        // Store pixel colors
        let pixels = [];
        
        // Get random color from palette
        function getRandomColor() {
            return colorPalette[Math.floor(Math.random() * colorPalette.length)];
        }
        
        // Initialize pixels with random colors
        function initializePixels() {
            pixels = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                pixels[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    pixels[y][x] = getRandomColor();
                }
            }
        }
        
        // Draw all pixels on canvas
        function drawPixels() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    ctx.fillStyle = pixels[y][x];
                    ctx.fillRect(
                        x * PIXEL_SIZE,
                        y * PIXEL_SIZE,
                        PIXEL_SIZE,
                        PIXEL_SIZE
                    );
                }
            }
        }
        
        // Function to resize canvas to fullscreen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GRID_WIDTH = Math.floor(canvas.width / PIXEL_SIZE);
            GRID_HEIGHT = Math.floor(canvas.height / PIXEL_SIZE);
            initializePixels();
            drawPixels();
        }
        
        // Initialize on load and on resize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Change all pixel colors
        function changeAllPixels() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    pixels[y][x] = getRandomColor();
                }
            }
            drawPixels();
        }
        
        // Create a reusable temporary canvas for text rendering
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // Function to draw text as pixels
        function drawPixelText(text, centerX, centerY, scale = 1) {
            ctx.save();
            
            // Use a small font and get pixel data
            const fontSize = 16 * scale;
            ctx.font = `bold ${fontSize}px monospace`;
            
            // Measure text
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            
            // Resize temporary canvas
            tempCanvas.width = textWidth + 10;
            tempCanvas.height = textHeight + 10;
            
            // Draw text on temp canvas
            tempCtx.font = ctx.font;
            tempCtx.fillStyle = '#ffffff';
            tempCtx.textBaseline = 'top';
            tempCtx.fillText(text, 5, 5);
            
            // Get pixel data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Draw pixels where text exists
            const startX = Math.floor(centerX - tempCanvas.width / 2);
            const startY = Math.floor(centerY - tempCanvas.height / 2);
            
            for (let y = 0; y < tempCanvas.height; y++) {
                for (let x = 0; x < tempCanvas.width; x++) {
                    const i = (y * tempCanvas.width + x) * 4;
                    const alpha = data[i + 3];
                    
                    if (alpha > 128) { // If pixel is visible
                        const pixelX = startX + x;
                        const pixelY = startY + y;
                        
                        if (pixelX >= 0 && pixelX < canvas.width && pixelY >= 0 && pixelY < canvas.height) {
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(pixelX, pixelY, 1, 1);
                        }
                    }
                }
            }
            
            ctx.restore();
        }
        
        // Function to format time
        function getTimeString() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        

        
        // Rotation state
        let rotation = 0;
        let lastRotationTime = Date.now();
        const ROTATION_INTERVAL = 5000; // Rotate every 5 seconds
        
        // Update function to draw pixels and time
        function update() {
            // Change pixel colors
            changeAllPixels();
            
            // Check if we should rotate
            const currentTime = Date.now();
            if (currentTime - lastRotationTime >= ROTATION_INTERVAL) {
                rotation = (rotation + 90) % 360;
                lastRotationTime = currentTime;
            }
            
            // Draw time with rotation
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate((rotation * Math.PI) / 180);
            
            const timeText = getTimeString();
            
            drawPixelText(timeText, 0, 0, 2);
            
            ctx.restore();
        }
        
        // Initialize and start
        // Note: initialization happens in resizeCanvas()
        
        // Update every second
        setInterval(update, 1000);
        update(); // Initial call
    </script>
</body>
</html>
